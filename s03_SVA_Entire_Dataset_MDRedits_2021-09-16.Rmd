---
title: "SVA on Entire Dataset"
output:
  html_document:
    df_print: paged
---

# Load Necessary Packages
```{r message=FALSE}
# install.packages("BiocManager")
# library(BiocManager)
# BiocManager::install("sva") # install sva package
# BiocManager::install("limma") # install limma package
# install.packages("tidyverse")
# install.packages("data.table")

rm(list = ls())
library(sva)
library(limma)
library(tidyverse)
library(data.table)
library(MASS)
library(car)
library(lme4)
```

# Load Datasets
```{r}
# set working directory for easy access of data
notebookDirectory = getwd()
setwd("../raw_data") 

# read in expression data
mdata <- data.frame(fread("Orthogroup_RNAseq_8-23-21.csv", header=T))
rownames(mdata) <- mdata$Orthogroups # Reset row names to orthogroup names, needed for SVA
#mdataNorm = melt(as.data.table(mdata))

mdata = mdata[,which(colnames(mdata) != "Orthogroups")]

# read in phenotype data
pheno <- read.csv("metadata_labels_keniaFixed.csv", header=T) 
rownames(pheno) <- pheno$sra # reset rownames to SRA accessions

# remove SRA accessions in pheno data that do not have expression data
pheno2 <- pheno[(rownames(pheno) %in% colnames(mdata)),] # SRAs in pheno that match mdata
pheno2$sample <- 1:nrow(pheno2) # create a sample column

#Extract species
print(unique(gsub("_[0-9]{1,3}", "", pheno2$NEW_sample_id)))

# look at the number of samples in each factor
table(pheno2$NEW_tissue) ; table(pheno2$NEW_stress) ; table(pheno2$NEW_family)

# read in Bioproject ID information that corresponds to pheno2
setwd(notebookDirectory)
bioproject <- read.delim("bioproject_ids.txt", header=F, sep=",")
colnames(bioproject) <- c("sra", "bioproject") # rename columns

# combine bioproject and pheno2
pheno2 <- left_join(pheno2, bioproject, by="sra") # combine by matching sra columns
write.csv(pheno2, "pheno_data.csv")

# visualize expression and phenotype data
head(mdata[,1:5]) ; head(pheno2)
```

# Normalize expression data
```{r, eval = F}
#Normlaize data
ggplot(mdataNorm, aes(x = value)) + geom_density()
ggplot(mdataNorm, aes(x = log(value + 1))) + geom_density()
mdataNorm$value = qqnorm(mdataNorm$value,plot.it =F)$x
ggplot(mdataNorm, aes(x = value)) + geom_density()

#Convert normalized expression back into matrix
mdataNorm = dcast(mdataNorm, Orthogroups ~ variable)
mdataNorm = as.data.frame(mdataNorm)

#Add orthogroup names to row names for sva
rownames(mdataNorm) <- mdataNorm$Orthogroups
mdataNorm = mdataNorm[,which(colnames(mdataNorm) != "Orthogroups")]
```

# Set Full and Null Models
```{r}
# full model matrix - family, stress, tissue should be sig
mod <- model.matrix(~NEW_stress+NEW_tissue+NEW_family, data=pheno2)
modNoFam <- model.matrix(~NEW_stress+NEW_tissue, data=pheno2)
modNoTis <- model.matrix(~NEW_stress+NEW_family, data=pheno2)
modStressOnly <- model.matrix(~NEW_stress, data=pheno2)

# null model matrix (no adjustment variables are included)
null_mod <- model.matrix(~1, data=pheno2)

# expression data must be a matrix
mdata <- as.matrix(mdata)
#mdataNorm = as.matrix(mdataNorm)
```

# Perform SVASeq on Entire Dataset
```{r}
# Estimate surrogate variables (SVs) using the two-step SVA method
startTime = Sys.time()
svseq_obj <- svaseq(mdata, mod, null_mod, method = "two-step")
endTime = Sys.time()
endTime - startTime

startTime = Sys.time()
svseq_obj_noFam <- svaseq(mdata, modNoFam, null_mod, method = "two-step")
endTime = Sys.time()
endTime - startTime

startTime = Sys.time()
svseq_obj_noTis <- svaseq(mdata, modNoTis, null_mod, method = "two-step")
endTime = Sys.time()
endTime - startTime

startTime = Sys.time()
svseq_obj_stressOnly <- svaseq(mdata, modStressOnly, null_mod, method = "two-step")
endTime = Sys.time()
endTime - startTime

svseq_obj$sv[1:5, 1:5] # visualize surrogate variables

# plot of first 2 surrogate variables
plot(svseq_obj$sv, pch=20, col="blue")

```

# PCA
```{r}
## Generate a clean matrix using a function by Andrew Jaffe
# This function removes the effects of SVs from our expression data
#'y' as the gene expresion matrix
#'mod' as the model matrix you sent to sva (the full model)
#'svs' as svobj$sv where svobj is the output from the sva function
cleanY = function(y, mod, svs) {
    X = cbind(mod, svs) # same as modSv
    Hat = solve(t(X) %*% X) %*% t(X)
    beta = (Hat %*% t(y))
    rm(Hat)
    gc()
    P = ncol(mod)
    return(y - t(as.matrix(X[,-c(1:P)]) %*% beta[-c(1:P),]))
}

#Remove effects of svs
clean_data_svs <- cleanY(mdata, mod, svseq_obj$sv)

#Remove effects of svs and family
clean_data_noFam <- cleanY(mdata, modNoFam, svseq_obj_noFam$sv)

#Remove effects of svs and tissue
clean_data_noTis <- cleanY(mdata, modNoTis, svseq_obj_noTis$sv)

#Remove effects of svs and family and tissue
clean_data_stressOnly = cleanY(mdata, modStressOnly, svseq_obj_stressOnly$sv)

# Function for plotting pca
plot_pca <- function(Legend, title){
  x %>% as.data.frame %>%
  ggplot(aes(x=PC1,y=PC2, col=Legend)) + geom_point() + 
  ggtitle(title) +
  labs(x=paste("PC1: ",round(var_explained[1]*100,2),"%"),
       y=paste("PC2: ",round(var_explained[2]*100,2),"%"))
}

# Plot PCA of cleaned matrix
pca.res <- prcomp(t(clean_data_svs), center = T, scale = T) # run PCA
pca.res$x[1:5,1:5] # visualize matrix of principle components (PCs)
var_explained <- pca.res$sdev^2/sum(pca.res$sdev^2) # explained variance for each PC
var_explained[1:5] # visualize matrix of explained variance per PC
x <- data.frame(pca.res$x) # create a dataframe of PCs
plot_pca(pheno2$NEW_stress, "PCA on Clean Data (Stress)")
plot_pca(pheno2$NEW_tissue, "PCA on Clean Data (Tissue)")
plot_pca(pheno2$NEW_family, "PCA on Clean Data (Family)")

# write cleaned data to file
write.csv(clean_data_svs, "clean_Orthogroup_RNAseq_onlySVsCorrected_9-14-21.csv", row.names = F, quote = F)
write.csv(clean_data_noFam, "clean_Orthogroup_RNAseq_FamilyCorrected_9-14-21.csv", row.names = F, quote = F)
write.csv(clean_data_noTis, "clean_Orthogroup_RNAseq_TissueCorrected_9-14-21.csv", row.names = F, quote = F)
write.csv(clean_data_stressOnly, "clean_Orthogroup_RNAseq_FamilyAndTissueCorrected_9-14-21.csv", row.names = F, quote = F)

```

# Calculate variance explained by SVs
```{r}
#Add surrogate variables to model matrix
modSv = cbind(mod,svseq_obj$sv)
fitSv = lmFit(mdata,modSv)
fitNoSv = lmFit(mdata,mod)
summary(fitNoSv)
summary(fitSv)

#Get fitted values to calculated residual variance
fittedValuesNoSv = fitted.values(fitNoSv)
fittedValuesSv = fitted.values(fitSv)

#Residual/error variance
resVarNoSV = rowSums((mdata - fittedValuesNoSv)^2)
resVarSv = rowSums((mdata - fittedValuesSv)^2)

#Total variance
calcTotalVar = function(x){
  sum((x - mean(x))^2)
}
totalVar = apply(mdata, MARGIN = 1, FUN = calcTotalVar)

#Proportion of variance explained (1 - unexplained variance)
explainVarNoSv = 1 - (resVarNoSV/totalVar)
explainVarSv = 1 - (resVarSv/totalVar)

#Calculate adjusted R^2
#Because the model with Svs has more predictors, it is guaranteed to always explain more variance than a model without SVs regardless of how much extra information SVs provide to the model
n = ncol(mdata) # number of datapoints
kSv = ncol(modSv) # number of predictors for model with SVs
kNoSv = ncol(mod) # number of predictors for model without SVs

adjExplainedVarNoSV = 1 - ((1 - explainVarNoSv)*(n - 1))/(n - kNoSv - 1)
adjExplainedVarSV = 1 - ((1 - explainVarSv)*(n - 1))/(n - kSv - 1)

#How much extra variance is explained when SVs are added?
diffVarExplained = explainVarSv - explainVarNoSv
adjDiffVarExplained = adjExplainedVarSV - adjExplainedVarNoSV

#Summarize results
hist(diffVarExplained, main = "Histogram of variance explained by SVs", ylab = "Number of orthogroups", xlab = "Proportion of variance explained by SVs")
hist(adjDiffVarExplained, main = "Histogram of variance explained by SVs", ylab = "Number of orthogroups", xlab = "Difference in adjusted R^2 for models with and without SVs")

summary(diffVarExplained)
summary(adjDiffVarExplained)

```

# Adjusting for SVs using `f.pvalue` Method from SVA Package
```{r}
# The f.pvalue function can be used to calculate parametric F-test p-values for each row of a data matrix
# The F-test compares the models mod and null_mod. They must be nested models, so all of the variables in null_mod must appear in mod.

# Calculate the F-test p-values for differential expression without adjusting for surrogate variables
pValues = f.pvalue(mdata,mod,null_mod)
qValues = p.adjust(pValues,method="BH")
head(pValues) ; head(qValues)

# Include the surrogate variables in both the null and full models to adjust for the surrogate variables by treating them as adjustment variables that must be included in both models. 
pValuesSv = f.pvalue(mdata,modSv,mod0Sv)
qValuesSv = p.adjust(pValuesSv,method="BH")
head(pValuesSv) ; head(qValuesSv)

# Identify orthogroups (OGs) that are NOT differentially expressed with respect to stress + tissue + family
length(pValuesSv[pValuesSv>0.05]) # 38 w/BH corrected p-value > 0.05
pValuesSv[pValuesSv>0.05] # corresponding OGs
```

# Correlation between SVs and Sample, Species, & BioProject
```{r}
# Multiple linear regression for testing the association between SVs and 3 batch variables: bioproject, sample, and species
test <- lm(svseq_obj$sv ~ bioproject + sample + species, data = pheno2)
summary(test)

########################################################################
SVs <- svseq_obj$sv[,1:2] # create a matrix of SVs

# Simple Linear Regression to test the association between bioproject and SVs
test2 <- lm(SVs~bioproject, data = pheno2) ; summary(test2)
## For SV1
#Residual standard error: 0.01359 on 962 degrees of freedom
#Multiple R-squared:  0.8224,	Adjusted R-squared:  0.8126 
#F-statistic: 84.05 on 53 and 962 DF,  p-value: < 2.2e-16
## For SV2
#Residual standard error: 0.0217 on 962 degrees of freedom
#Multiple R-squared:  0.547,	Adjusted R-squared:  0.5221 
#F-statistic: 21.92 on 53 and 962 DF,  p-value: < 2.2e-16

# Simple Linear Regression to test the association between sample and SVs
test3 <- lm(SVs~sample, data = pheno2) ; summary(test3)
## For SV1
#Residual standard error: 0.02646 on 1014 degrees of freedom
#Multiple R-squared:  0.2902,	Adjusted R-squared:  0.2895 
#F-statistic: 414.6 on 1 and 1014 DF,  p-value: < 2.2e-16
## For SV2
#Residual standard error: 0.03045 on 1014 degrees of freedom
#Multiple R-squared:  0.05952,	Adjusted R-squared:  0.05859 
#F-statistic: 64.17 on 1 and 1014 DF,  p-value: 3.119e-15

# Simple Linear Regression to test the association between species and SVs
test4 <- lm(SVs~species, data = pheno2) ; summary(test4)
## For SV1
#Residual standard error: 0.01563 on 995 degrees of freedom
#Multiple R-squared:  0.7569,	Adjusted R-squared:  0.752 
#F-statistic: 154.9 on 20 and 995 DF,  p-value: < 2.2e-16
## For SV2
#Residual standard error: 0.02625 on 995 degrees of freedom
#Multiple R-squared:  0.3145,	Adjusted R-squared:  0.3008 
#F-statistic: 22.83 on 20 and 995 DF,  p-value: < 2.2e-16
```
BioProject and Species are colinear due to each bioproject corresponding to a single species. No batch correction by BioProject will be performed since it is highly correlated with the surrogate variables.

